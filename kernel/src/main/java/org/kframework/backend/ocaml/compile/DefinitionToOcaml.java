package org.kframework.backend.ocaml.compile;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.SetMultimap;
import org.kframework.attributes.Source;
import org.kframework.builtin.BooleanUtils;
import org.kframework.builtin.Sorts;
import org.kframework.definition.Module;
import org.kframework.definition.ModuleTransformer;
import org.kframework.definition.Production;
import org.kframework.definition.Rule;
import org.kframework.kil.Attribute;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kore.InjectedKLabel;
import org.kframework.kore.K;
import org.kframework.kore.KApply;
import org.kframework.kore.KLabel;
import org.kframework.kore.KRewrite;
import org.kframework.kore.KSequence;
import org.kframework.kore.KToken;
import org.kframework.kore.KVariable;
import org.kframework.kore.Sort;
import org.kframework.kore.ToKast;
import org.kframework.kore.compile.ConvertDataStructureToLookup;
import org.kframework.kore.compile.GenerateSortPredicates;
import org.kframework.kore.compile.RewriteToTop;
import org.kframework.kore.compile.VisitKORE;
import org.kframework.krun.KRun;
import org.kframework.main.GlobalOptions;
import org.kframework.utils.BinaryLoader;
import org.kframework.utils.StringUtil;
import org.kframework.utils.errorsystem.KEMException;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import scala.Function1;

import java.io.File;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static org.kframework.Collections.*;
import static org.kframework.kore.KORE.*;
import static scala.compat.java8.JFunction.*;

public class DefinitionToOcaml {

    public static void main(String[] args) {
        KExceptionManager kem = new KExceptionManager(new GlobalOptions());
        CompiledDefinition def = new BinaryLoader(kem).loadOrDie(CompiledDefinition.class, new File(args[0]));

        BiFunction<String, Source, K> programParser = def.getProgramParser(kem);

        K program = programParser.apply(
                "int s, n, .Ids; n = 10; while(0<=n) { s = s + n; n = n + -1; }", Source.apply("generated by DefinitionToOcaml"));

        DefinitionToOcaml convert = new DefinitionToOcaml();
        String ocaml = convert.convert(def);
        FileUtil.testFileUtil().saveToWorkingDirectory("def.sml", ocaml);
        String pgm = convert.convert(new KRun(kem, FileUtil.testFileUtil()).plugConfigVars(def, Collections.singletonMap(KToken(Sorts.KConfigVar(), "$PGM"), program)));
        FileUtil.testFileUtil().saveToWorkingDirectory("pgm.ml", pgm);
    }

    public static final String prelude = "open LargeInt\n" +
            "open IntBinaryMap\n" +
            "open TextIO\n" +
            "datatype k = KApply of klabel * k list\n" +
            "           | KToken of sort * string\n" +
            "           | InjectedKLabel of klabel\n" +
            "           | KSequence of k list\n" +
            "           | Map of k map \n" +
            "           | List of k list\n" +
            "           | Int of int\n" +
            "           | String of string\n" +
            "           | Bool of bool\n" +
            "exception Stuck of k\n";


    public static final String TRUE = "(Bool true)";

    public static final String midlude = "fun isTrue " + TRUE + " = true\n" +
            "| isTrue _ = false\n" +
            "fun " +
            " print_k (KApply(klabel, klist)) = (print(print_klabel(klabel)); print \"(\"; print_klist(klist); print \")\")\n" +
            "| print_k (KToken(sort, s)) = (print \"#token(\"; print(print_sort(sort)); print (\", \\\"\" ^ s ^ \"\\\")\"))\n" +
            "| print_k (InjectedKLabel(klabel)) = (print \"#klabel(\"; print(print_klabel(klabel)); print(\")\"))\n" +
            "| print_k (KSequence(k)) = print_ksequence(k)\n" +
            "| print_k (Bool(b)) = print_k(KToken(LblBool, string_of_bool(b)))\n" +
            "| print_k (Int(i)) = print_k(KToken(LblInt, string_of_int(i)))\n" +
            "and " +
            " print_klist nil = print(\".KList\")\n" +
            "| print_klist(e::l) = (print_k(e); print(\", \"); print_klist(l))\n" +
            "and " +
            " print_ksequence nil = print(\".K\")\n" +
            "| print_ksequence(e::l) = (print_k(e); print(\" ~> \"); print_ksequence(l))\n";

    public static final String postlude = "let run c =\n" +
            "  try let rec go c = go (step c)\n" +
            "      in go c\n" +
            "  handle Stuck c' => c'\n";

    public static final ImmutableMap<String, String> hooks;
    public static final ImmutableMap<String, Function<String, String>> sortHooks;
    public static final ImmutableMap<String, String> predicateRules;

    static {
        ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();
        builder.put("#INT:_%Int_", "Int a :: Int b :: nil = Int (a mod b)");
        builder.put("Map:_|->_", "k1 :: k2 :: nil = Map (KMap.add k1 k2 KMap.empty)");
        builder.put("Map:.Map", "nil = Map KMap.empty");
        builder.put("Map:__", "Map k1 :: Map k2 :: nil = Map (KMap.merge (fun k a b = match a, b with None, None -> None | None, Some v | Some v, None -> Some v) k1 k2)");
        builder.put("Map:lookup", "Map k1 :: k2 :: nil = KMap.find k2 k1");
        builder.put("MetaK:#tokenSort", "KToken (sort, s) :: nil = String (print_sort sort) | _ = String \"\"");
        builder.put("#K-EQUAL:_==K_", "k1 :: k2 :: nil = Bool (k1 = k2)");
        builder.put("#BOOL:_andBool_", "Bool b1 :: Bool b2 :: nil = Bool (b1 && b2)");
        hooks = builder.build();
    }

    static {
        ImmutableMap.Builder<String, Function<String, String>> builder = ImmutableMap.builder();
        builder.put("#BOOL", s -> "(Bool " + s + ")");
        builder.put("#INT", s -> "(Int " + s + ")");
        builder.put("#STRING", s -> "(String " + StringUtil.enquoteCString(StringUtil.unquoteKString(s)) + ")");
        sortHooks = builder.build();
    }

    static {
        ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();
        builder.put("isK", "k1 :: nil = Bool true");
        predicateRules = builder.build();
    }

    private Module mainModule;

    public String convert(CompiledDefinition def) {
        ModuleTransformer convertLookups = ModuleTransformer.fromSentenceTransformer(new ConvertDataStructureToLookup(def.executionModule())::convert, "convert data structures to lookups");
        Function1<Module, Module> generatePredicates = func(new GenerateSortPredicates(def.kompiledDefinition)::gen);
        Function1<Module, Module> pipeline = convertLookups.andThen(generatePredicates);
        mainModule = pipeline.apply(def.executionModule());
        return convert();
    }

    Set<KLabel> functions;

    public String convert(K k) {
        StringBuilder sb = new StringBuilder();
        sb.append("open Def\n");
        sb.append("let _ = try print_k(run(");
        convert(sb, v -> {
            throw KEMException.criticalError("Ocaml backend does not support symbolic terms.", v);
        }).apply(k);
        sb.append(")) handle Stuck c' => print_k c'");
        return sb.toString();
    }

    private String convert() {
        StringBuilder sb = new StringBuilder();
        String conn = "";
        sb.append("datatype sort = ");
        for (Sort s : iterable(mainModule.definedSorts())) {
            sb.append(conn);
            encodeStringToIdentifier(sb, s.name());
            sb.append("\n");
            conn = "| ";
        }
        sb.append("datatype klabel = ");
        conn = "";
        for (KLabel label : iterable(mainModule.definedKLabels())) {
            sb.append(conn);
            encodeStringToIdentifier(sb, label.name());
            sb.append("\n");
            conn = "| ";
        }
        sb.append(prelude);
        sb.append("fun print_sort ");
        conn = "";
        for (Sort s : iterable(mainModule.definedSorts())) {
            sb.append(conn);
            encodeStringToIdentifier(sb, s.name());
            sb.append(" = ");
            sb.append(StringUtil.enquoteCString(StringUtil.enquoteKString(s.name())));
            sb.append("\n");
            conn = "| print_sort ";
        }
        sb.append("fun print_klabel \n");
        conn = "";
        for (KLabel label : iterable(mainModule.definedKLabels())) {
            sb.append(conn);
            encodeStringToIdentifier(sb, label.name());
            sb.append(" = ");
            sb.append(StringUtil.enquoteCString(ToKast.apply(label)));
            sb.append("\n");
            conn = "| print_klabel ";
        }
        sb.append(midlude);
        HashMultimap<KLabel, Rule> functionRules = HashMultimap.create();
        for (Rule r : iterable(mainModule.rules())) {
            K left = RewriteToTop.toLeft(r.body());
            boolean isFunction = left instanceof KApply && mainModule.attributesFor().apply(((KApply)left).klabel()).contains(Attribute.FUNCTION_KEY);
            if (isFunction) {
                functionRules.put(((KApply) left).klabel(), r);
            }
        }
        functions = new HashSet<>(functionRules.keySet());
        for (Production p : iterable(mainModule.productions())) {
            if (p.att().contains(Attribute.FUNCTION_KEY)) {
                functions.add(p.klabel().get());
            }
        }
        conn = "fun ";
        for (KLabel functionLabel : functions) {
            String hook = mainModule.attributesFor().apply(functionLabel).<String>getOptional(Attribute.HOOK_KEY).orElse("");
            if (hooks.containsKey(hook)) {
                sb.append(conn);
                encodeStringToFunction(sb, functionLabel.name());
                sb.append(hooks.get(hook));
                sb.append("\n");
                conn = " | ";
            }
            if (predicateRules.containsKey(functionLabel.name())) {
                sb.append(conn);
                encodeStringToFunction(sb, functionLabel.name());
                sb.append(predicateRules.get(functionLabel.name()));
                sb.append("\n");
                conn = " | ";
            }
            for (Rule r : functionRules.get(functionLabel).stream().sorted((a1, a2) -> Boolean.compare(a1.att().contains("owise"), a2.att().contains("owise"))).collect(Collectors.toList())) {
                sb.append(conn);
                encodeStringToFunction(sb, functionLabel.name());
                convert(r, sb, true);
                conn = " | ";
            }
            sb.append(conn);
            encodeStringToFunction(sb, functionLabel.name());
            sb.append(" _ = raise (Stuck (KApply (");
            encodeStringToIdentifier(sb, functionLabel.name());
            sb.append(", l)))\n");
            conn = " and ";
        }
        sb.append("fun");
        conn = "";
        for (Rule r : iterable(mainModule.rules())) {
            if (!functionRules.values().contains(r)) {
                sb.append(conn);
                sb.append(" step ");
                convert(r, sb, false);
                conn = "| ";
            }
        }
        sb.append("| _ = raise (Stuck c)\n");
        sb.append(postlude);
        return sb.toString();
    }

    private static void encodeStringToIdentifier(StringBuilder sb, String name) {
        sb.append("Lbl");
        encodeStringToAlphanumeric(sb, name);
    }

    private static void encodeStringToFunction(StringBuilder sb, String name) {
        sb.append("eval");
        encodeStringToAlphanumeric(sb, name);
    }

    private static long counter = 0;

    private static String encodeStringToVariable(StringBuilder sb, String name) {
        StringBuilder sb2 = new StringBuilder();
        sb2.append("var");
        encodeStringToAlphanumeric(sb2, name);
        sb2.append("_");
        sb2.append(counter++);
        sb.append(sb2);
        return sb2.toString();
    }

    public static final Pattern identChar = Pattern.compile("[A-Za-z0-9_]");

    private static void encodeStringToAlphanumeric(StringBuilder sb, String name) {
        boolean inIdent = true;
        for (int i = 0; i < name.length(); i++) {
            if (identChar.matcher(name).region(i, name.length()).lookingAt()) {
                if (!inIdent) {
                    inIdent = true;
                    sb.append("'");
                }
                sb.append(name.charAt(i));
            } else {
                if (inIdent) {
                    inIdent = false;
                    sb.append("'");
                }
                sb.append(String.format("%04x", (int)name.charAt(i)));
            }
        }
    }


    private void convert(Rule r, StringBuilder sb, boolean function) {
        sb.append("(* rule ");
        sb.append(ToKast.apply(r.body()));
        sb.append(" requires ");
        sb.append(ToKast.apply(r.requires()));
        sb.append(" ensures ");
        sb.append(ToKast.apply(r.ensures()));
        sb.append(" ");
        sb.append(r.att().toString());
        sb.append("*)\n");
        sb.append("(");
        K left = RewriteToTop.toLeft(r.body());
        K right = RewriteToTop.toRight(r.body());
        K requires = r.requires();
        SetMultimap<KVariable, String> vars = HashMultimap.create();
        Visitor visitor = convert(sb, v -> applyVarLhs(v, sb, vars));
        if (function) {
            assert left instanceof KApply;
            KApply kapp = (KApply) left;
            visitor.apply(kapp.klist().items());
        } else {
            visitor.apply(left);
        }
        sb.append(")");
        String result = convert(vars);
        Holder numLookups = new Holder();
        if (!(result.equals("true") && requires.equals(BooleanUtils.TRUE))) {
            sb.append(convertLookups(requires, vars, numLookups));
            sb.append(" when isTrue(");
            convert(sb, v -> applyVarRhs(v, sb, vars)).apply(requires);
            sb.append(") && (");
            sb.append(result);
            sb.append(")");
        }
        sb.append(" = ");
        convert(sb, v -> applyVarRhs(v, sb, vars)).apply(right);
        for (int i = 0; i < numLookups.i; i++) {
            sb.append(")");
        }
        sb.append("\n");
    }

    private static class Holder { int i; }

    private String convertLookups(K requires, SetMultimap<KVariable, String> vars, Holder h) {
        StringBuilder sb = new StringBuilder();
        h.i = 0;
        new VisitKORE() {
            @Override
            public Void apply(KApply k) {
                if (k.klabel().name().equals("#match")) {
                    if (k.klist().items().size() != 2) {
                        throw KEMException.internalError("Unexpected arity of lookup: " + k.klist().size(), k);
                    }
                    convertLookup(sb, k.klist().items().get(0), k.klist().items().get(1), vars);
                    h.i++;
                }
                return super.apply(k);
            }
        }.apply(requires);
        return sb.toString();
    }

    private void convertLookup(StringBuilder sb, K lhs, K rhs, SetMultimap<KVariable, String> vars) {
        sb.append(" -> (match ");
        convert(sb, v -> applyVarRhs(v, sb, vars)).apply(rhs);
        sb.append(" with \n");
        convert(sb, v -> applyVarLhs(v, sb, vars)).apply(lhs);
    }

    private static String convert(SetMultimap<KVariable, String> vars) {
        StringBuilder sb = new StringBuilder();
        for (Collection<String> nonLinearVars : vars.asMap().values()) {
            if (nonLinearVars.size() < 2) {
                continue;
            }
            Iterator<String> iter = nonLinearVars.iterator();
            String last = iter.next();
            while (iter.hasNext()) {
                String next = iter.next();
                sb.append(last);
                sb.append(" = ");
                sb.append(next);
                last = next;
                sb.append(" && ");
            }
        }
        sb.append("true");
        return sb.toString();
    }

    private static void applyVarRhs(KVariable v, StringBuilder sb, SetMultimap<KVariable, String> vars) {
        sb.append(vars.get(v).iterator().next());
    }

    private static void applyVarLhs(KVariable k, StringBuilder sb, SetMultimap<KVariable, String> vars) {
        String varName = encodeStringToVariable(sb, k.name());
        vars.put(k, varName);
    }

    private Visitor convert(StringBuilder sb, Consumer<KVariable> convertVar) {
        return new Visitor(sb, convertVar);
    }

    private class Visitor extends VisitKORE {
        private final StringBuilder sb;
        private final Consumer<KVariable> convertVar;

        public Visitor(StringBuilder sb, Consumer<KVariable> convertVar) {
            this.sb = sb;
            this.convertVar = convertVar;
        }

        @Override
        public Void apply(KApply k) {
            if (k.klabel().name().equals("#match")) {
                sb.append(TRUE);
            } else if (functions.contains(k.klabel())) {
                encodeStringToFunction(sb, k.klabel().name());
                sb.append("(");
                apply(k.klist().items());
                sb.append(")");
            } else {
                sb.append("KApply (");
                apply(k.klabel());
                sb.append(", ");
                apply(k.klist().items());
                sb.append(")");
            }
            return null;
        }

        @Override
        public Void apply(KRewrite k) {
            throw new AssertionError("unexpected rewrite");
        }

        @Override
        public Void apply(KToken k) {
            if (mainModule.sortAttributesFor().contains(k.sort())) {
                String hook = mainModule.sortAttributesFor().apply(k.sort()).<String>getOptional("hook").orElse("");
                if (sortHooks.containsKey(hook)) {
                    sb.append(sortHooks.get(hook).apply(k.s()));
                    return null;
                }
            }
            sb.append("KToken (");
            apply(k.sort());
            sb.append(", ");
            sb.append(StringUtil.enquoteCString(k.s()));
            sb.append(")");
            return null;
        }

        @Override
        public Void apply(KVariable k) {
            convertVar.accept(k);
            return null;
        }

        @Override
        public Void apply(KSequence k) {
            sb.append("KSequence (");
            apply(k.items());
            sb.append(")");
            return null;
        }

        @Override
        public Void apply(InjectedKLabel k) {
            sb.append("InjectedKLabel (");
            apply(k.klabel());
            sb.append(")");
            return null;
        }

        private void apply(List<K> items) {
            for (K item : items) {
                apply(item);
                sb.append(" :: ");
            }
            sb.append("nil");
        }

        private void apply(Sort sort) {
            encodeStringToIdentifier(sb, sort.name());
        }

        public void apply(KLabel klabel) {
            if (klabel instanceof KVariable) {
                convertVar.accept((KVariable)klabel);
            } else {
                encodeStringToIdentifier(sb, klabel.name());
            }
        }
    }
}
