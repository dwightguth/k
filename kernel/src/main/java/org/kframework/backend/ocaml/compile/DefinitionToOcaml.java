package org.kframework.backend.ocaml.compile;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.SetMultimap;
import org.kframework.attributes.Source;
import org.kframework.builtin.BooleanUtils;
import org.kframework.builtin.Sorts;
import org.kframework.definition.Module;
import org.kframework.definition.ModuleTransformer;
import org.kframework.definition.Production;
import org.kframework.definition.Rule;
import org.kframework.kil.Attribute;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kore.InjectedKLabel;
import org.kframework.kore.K;
import org.kframework.kore.KApply;
import org.kframework.kore.KLabel;
import org.kframework.kore.KRewrite;
import org.kframework.kore.KSequence;
import org.kframework.kore.KToken;
import org.kframework.kore.KVariable;
import org.kframework.kore.Sort;
import org.kframework.kore.ToKast;
import org.kframework.kore.compile.ConvertDataStructureToLookup;
import org.kframework.kore.compile.GenerateSortPredicates;
import org.kframework.kore.compile.RewriteToTop;
import org.kframework.kore.compile.VisitKORE;
import org.kframework.krun.KRun;
import org.kframework.main.GlobalOptions;
import org.kframework.utils.BinaryLoader;
import org.kframework.utils.StringUtil;
import org.kframework.utils.errorsystem.KEMException;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import scala.Function1;

import java.io.File;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;

import static org.kframework.Collections.*;
import static org.kframework.kore.KORE.*;
import static scala.compat.java8.JFunction.*;

public class DefinitionToOcaml {

    public static void main(String[] args) {
        KExceptionManager kem = new KExceptionManager(new GlobalOptions());
        CompiledDefinition def = new BinaryLoader(kem).loadOrDie(CompiledDefinition.class, new File(args[0]));

        BiFunction<String, Source, K> programParser = def.getProgramParser(kem);

        K program = programParser.apply(
                "int s, n, .Ids; n = 10; while(0<=n) { s = s + n; n = n + -1; }", Source.apply("generated by DefinitionToOcaml"));

        DefinitionToOcaml convert = new DefinitionToOcaml();
        String ocaml = convert.convert(def);
        FileUtil.testFileUtil().saveToWorkingDirectory("def.ml", ocaml);
        String pgm = convert.convert(new KRun(kem, FileUtil.testFileUtil()).plugConfigVars(def, Collections.singletonMap(KToken(Sorts.KConfigVar(), "$PGM"), program)));
        FileUtil.testFileUtil().saveToWorkingDirectory("pgm.ml", pgm);
    }

    public static final String kType = "t = KApply of klabel * t list\n" +
            "           | KToken of sort * string\n" +
            "           | InjectedKLabel of klabel\n" +
            "           | KSequence of t list\n" +
            "           | Map of t m\n" +
            "           | List of t list\n" +
            "           | Int of int\n" +
            "           | String of string\n" +
            "           | Bool of bool\n";

    public static final String prelude = "module type S =\n" +
            "sig\n" +
            "  type 'a m\n" +
            "  type " + kType +
            "  val compare : t -> t -> int\n" +
            "end \n" +
            "\n" +
            "\n" +
            "module rec K : (S with type 'a m = 'a Map.Make(K).t)  = \n" +
            "struct\n" +
            "  type 'a m = 'a Map.Make(K).t\n" +
            "  and " + kType +
            "  let compare a b = if a < b then -1 else if b < a then 1 else 0\n" +
            "end\n" +
            "\n" +
            "module KMap = Map.Make(K)\n" +
            "\n" +
            "open K\n" +
            "type k = K.t" +
            "\n" +
            "exception Stuck of k\n";

    public static final String TRUE = "(Bool true)";

    public static final String midlude = "let isTrue(c: k) : bool = match c with\n" +
            "| " + TRUE + " -> true\n" +
            "| _ -> false\n" +
            "let rec print_k(c: k) : unit = match c with\n" +
            "| KApply(klabel, klist) -> print_string(print_klabel(klabel)); print_string \"(\"; print_klist(klist); print_string \")\"\n" +
            "| KToken(sort, s) -> print_string \"#token(\"; print_string(print_sort(sort)); print_string (\", \\\"\" ^ s ^ \"\\\")\")\n" +
            "| InjectedKLabel(klabel) -> print_string \"#klabel(\"; print_string(print_klabel(klabel)); print_string(\")\")\n" +
            "| KSequence(k) -> print_ksequence(k)\n" +
            "| Bool(b) -> print_k(KToken(Lbl0042006f006f006c, string_of_bool(b)))\n" +
            "| Int(i) -> print_k(KToken(Lbl0049006e0074, string_of_int(i)))\n" +
            "| Map(m) -> KMap.iter (fun k v -> print_string(\"`_|->_`(\"); print_k(k); print_string(\", \"); print_k(v); print_string(\")\")) m\n" +
            "and print_klist(c: k list) : unit = match c with\n" +
            "| [] -> print_string(\".KList\")\n" +
            "| e::l -> print_k(e); print_string(\", \"); print_klist(l)\n" +
            "and print_ksequence(c: k list) : unit = match c with\n" +
            "| [] -> print_string(\".K\")\n" +
            "| e::l -> print_k(e); print_string(\" ~> \"); print_ksequence(l)\n";

    public static final String postlude = "let run c =\n" +
            "  try let rec go c = go (step c)\n" +
            "      in go c\n" +
            "  with Stuck c' -> c'\n";

    public static final ImmutableMap<String, String> hooks;
    public static final ImmutableMap<String, Function<String, String>> sortHooks;
    static {
        ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();
        builder.put("#INT:_%Int_", "Int a :: Int b :: [] -> Int (a mod b)");
        builder.put("Map:_|->_", "k1 :: k2 :: [] -> Map (KMap.add k1 k2 KMap.empty)");
        builder.put("Map:.Map", "[] -> Map KMap.empty");
        builder.put("Map:__", "Map k1 :: Map k2 :: [] -> Map (KMap.merge (fun k a b -> match a, b with None, None -> None | None, Some v | Some v, None -> Some v) k1 k2)");
        builder.put("Map:lookup", "Map k1 :: k2 :: [] -> KMap.find k2 k1");
        builder.put("MetaK:#tokenSort", "KToken (sort, s) -> String print_sort(sort))");
        builder.put("#K-EQUAL:_==K_", "k1 :: k2 :: [] -> Bool (k1 = k2)");
        builder.put("#BOOL:_andBool_", "Bool b1 :: Bool b2 :: [] -> Bool (b1 && b2)");
        hooks = builder.build();
    }

    static {
        ImmutableMap.Builder<String, Function<String, String>> builder = ImmutableMap.builder();
        builder.put("#BOOL", s -> "(Bool " + s + ")");
        builder.put("#INT", s -> "(Int " + s + ")");
        builder.put("#STRING", s -> "(String " + StringUtil.enquoteCString(StringUtil.unquoteKString(s)));
        sortHooks = builder.build();
    }

    private Module mainModule;

    public String convert(CompiledDefinition def) {
        ModuleTransformer convertLookups = ModuleTransformer.fromSentenceTransformer(new ConvertDataStructureToLookup(def.executionModule())::convert, "convert data structures to lookups");
        Function1<Module, Module> generatePredicates = func(new GenerateSortPredicates()::gen);
        Function1<Module, Module> pipeline = convertLookups.andThen(generatePredicates);
        mainModule = pipeline.apply(def.executionModule());
        return convert();
    }

    Set<KLabel> functions;

    public String convert(K k) {
        StringBuilder sb = new StringBuilder();
        sb.append("open Def\n");
        sb.append("let _ = try print_k(run(");
        convert(sb, v -> {
            throw KEMException.criticalError("Ocaml backend does not support symbolic terms.", v);
        }).apply(k);
        sb.append(")) with Stuck c' -> print_k c'");
        return sb.toString();
    }

    private String convert() {
        StringBuilder sb = new StringBuilder();
        sb.append("type sort = ");
        for (Sort s : iterable(mainModule.definedSorts())) {
            sb.append("|");
            encodeStringToIdentifier(sb, s.name());
            sb.append("\n");
        }
        sb.append("type klabel = ");
        for (KLabel label : iterable(mainModule.definedKLabels())) {
            sb.append("|");
            encodeStringToIdentifier(sb, label.name());
            sb.append("\n");
        }
        sb.append(prelude);
        sb.append("let print_sort(c: sort) : string = match c with \n");
        for (Sort s : iterable(mainModule.definedSorts())) {
            sb.append("|");
            encodeStringToIdentifier(sb, s.name());
            sb.append(" -> ");
            sb.append(StringUtil.enquoteCString(StringUtil.enquoteKString(s.name())));
            sb.append("\n");
        }
        sb.append("let print_klabel(c: klabel) : string = match c with \n");
        for (KLabel label : iterable(mainModule.definedKLabels())) {
            sb.append("|");
            encodeStringToIdentifier(sb, label.name());
            sb.append(" -> ");
            sb.append(StringUtil.enquoteCString(ToKast.apply(label)));
            sb.append("\n");
        }
        sb.append(midlude);
        HashMultimap<KLabel, Rule> functionRules = HashMultimap.create();
        for (Rule r : iterable(mainModule.rules())) {
            K left = RewriteToTop.toLeft(r.body());
            boolean isFunction = left instanceof KApply && mainModule.attributesFor().apply(((KApply)left).klabel()).contains(Attribute.FUNCTION_KEY);
            if (isFunction) {
                functionRules.put(((KApply)left).klabel(), r);
            }
        }
        functions = new HashSet<>(functionRules.keySet());
        for (Production p : iterable(mainModule.productions())) {
            if (p.att().contains(Attribute.FUNCTION_KEY)) {
                functions.add(p.klabel().get());
            }
        }
        String conn = "let rec ";
        for (KLabel functionLabel : functions) {
            sb.append(conn);
            encodeStringToFunction(sb, functionLabel.name());
            sb.append(" (l: k list) : k = match l with \n");
            String hook = mainModule.attributesFor().apply(functionLabel).<String>getOptional(Attribute.HOOK_KEY).orElse("");
            if (hooks.containsKey(hook)) {
                sb.append("| ");
                sb.append(hooks.get(hook));
            }
            for (Rule r : functionRules.get(functionLabel).stream().sorted((a1, a2) -> Boolean.compare(a1.att().contains("owise"), a2.att().contains("owise"))).collect(Collectors.toList())) {
                convert(r, sb, true);
            }
            sb.append("| _ -> raise (Stuck (KApply (");
            encodeStringToIdentifier(sb, functionLabel.name());
            sb.append(", l)))\n");
            conn = "and ";
        }
        sb.append("let step (c: k) : k = match c with \n");
        for (Rule r : iterable(mainModule.rules())) {
            if (!functionRules.values().contains(r)) {
                convert(r, sb, false);
            }
        }
        sb.append("| _ -> raise (Stuck c)\n");
        sb.append(postlude);
        return sb.toString();
    }

    private static void encodeStringToIdentifier(StringBuilder sb, String name) {
        sb.append("Lbl");
        encodeStringToAlphanumeric(sb, name);
    }

    private static void encodeStringToFunction(StringBuilder sb, String name) {
        sb.append("eval");
        encodeStringToAlphanumeric(sb, name);
    }

    private static long counter = 0;

    private static String encodeStringToVariable(StringBuilder sb, String name) {
        StringBuilder sb2 = new StringBuilder();
        sb2.append("var");
        encodeStringToAlphanumeric(sb2, name);
        sb2.append("_");
        sb2.append(counter++);
        sb.append(sb2);
        return sb2.toString();
    }

    private static void encodeStringToAlphanumeric(StringBuilder sb, String name) {
        for (char c : name.toCharArray()) {
            sb.append(String.format("%04x", (int)c));
        }
    }


    private void convert(Rule r, StringBuilder sb, boolean function) {
        sb.append("(* rule ");
        sb.append(ToKast.apply(r.body()));
        sb.append(" requires ");
        sb.append(ToKast.apply(r.requires()));
        sb.append(" ensures ");
        sb.append(ToKast.apply(r.ensures()));
        sb.append(" ");
        sb.append(r.att().toString());
        sb.append("*)\n");
        sb.append("| ");
        K left = RewriteToTop.toLeft(r.body());
        K right = RewriteToTop.toRight(r.body());
        K requires = r.requires();
        SetMultimap<KVariable, String> vars = HashMultimap.create();
        Visitor visitor = convert(sb, v -> applyVarLhs(v, sb, vars));
        if (function) {
            assert left instanceof KApply;
            KApply kapp = (KApply) left;
            visitor.apply(kapp.klist().items());
        } else {
            visitor.apply(left);
        }
        String result = convert(vars);
        Holder numLookups = new Holder();
        if (!(result.equals("true") && requires.equals(BooleanUtils.TRUE))) {
            sb.append(convertLookups(requires, vars, numLookups));
            sb.append(" when isTrue(");
            convert(sb, v -> applyVarRhs(v, sb, vars)).apply(requires);
            sb.append(") && (");
            sb.append(result);
            sb.append(")");
        }
        sb.append(" -> ");
        convert(sb, v -> applyVarRhs(v, sb, vars)).apply(right);
        for (int i = 0; i < numLookups.i; i++) {
            sb.append(")");
        }
        sb.append("\n");
    }

    private static class Holder { int i; }

    private String convertLookups(K requires, SetMultimap<KVariable, String> vars, Holder h) {
        StringBuilder sb = new StringBuilder();
        h.i = 0;
        new VisitKORE() {
            @Override
            public Void apply(KApply k) {
                if (k.klabel().name().equals("#match")) {
                    if (k.klist().items().size() != 2) {
                        throw KEMException.internalError("Unexpected arity of lookup: " + k.klist().size(), k);
                    }
                    convertLookup(sb, k.klist().items().get(0), k.klist().items().get(1), vars);
                    h.i++;
                }
                return super.apply(k);
            }
        }.apply(requires);
        return sb.toString();
    }

    private void convertLookup(StringBuilder sb, K lhs, K rhs, SetMultimap<KVariable, String> vars) {
        sb.append(" -> (match ");
        convert(sb, v -> applyVarRhs(v, sb, vars)).apply(rhs);
        sb.append(" with \n");
        convert(sb, v -> applyVarLhs(v, sb, vars)).apply(lhs);
    }

    private static String convert(SetMultimap<KVariable, String> vars) {
        StringBuilder sb = new StringBuilder();
        for (Collection<String> nonLinearVars : vars.asMap().values()) {
            if (nonLinearVars.size() < 2) {
                continue;
            }
            Iterator<String> iter = nonLinearVars.iterator();
            String last = iter.next();
            while (iter.hasNext()) {
                String next = iter.next();
                sb.append(last);
                sb.append(" = ");
                sb.append(next);
                last = next;
                sb.append(" && ");
            }
        }
        sb.append("true");
        return sb.toString();
    }

    private static void applyVarRhs(KVariable v, StringBuilder sb, SetMultimap<KVariable, String> vars) {
        sb.append(vars.get(v).iterator().next());
    }

    private static void applyVarLhs(KVariable k, StringBuilder sb, SetMultimap<KVariable, String> vars) {
        String varName = encodeStringToVariable(sb, k.name());
        vars.put(k, varName);
    }

    private Visitor convert(StringBuilder sb, Consumer<KVariable> convertVar) {
        return new Visitor(sb, convertVar);
    }

    private class Visitor extends VisitKORE {
        private final StringBuilder sb;
        private final Consumer<KVariable> convertVar;

        public Visitor(StringBuilder sb, Consumer<KVariable> convertVar) {
            this.sb = sb;
            this.convertVar = convertVar;
        }

        @Override
        public Void apply(KApply k) {
            if (k.klabel().name().equals("#match")) {
                sb.append(TRUE);
            } else if (functions.contains(k.klabel())) {
                encodeStringToFunction(sb, k.klabel().name());
                sb.append("(");
                apply(k.klist().items());
                sb.append(")");
            } else {
                sb.append("KApply (");
                apply(k.klabel());
                sb.append(", ");
                apply(k.klist().items());
                sb.append(")");
            }
            return null;
        }

        @Override
        public Void apply(KRewrite k) {
            throw new AssertionError("unexpected rewrite");
        }

        @Override
        public Void apply(KToken k) {
            if (mainModule.sortAttributesFor().contains(k.sort())) {
                String hook = mainModule.sortAttributesFor().apply(k.sort()).<String>getOptional("hook").orElse("");
                if (sortHooks.containsKey(hook)) {
                    sb.append(sortHooks.get(hook).apply(k.s()));
                    return null;
                }
            }
            sb.append("KToken (");
            apply(k.sort());
            sb.append(", ");
            sb.append(StringUtil.enquoteCString(k.s()));
            sb.append(")");
            return null;
        }

        @Override
        public Void apply(KVariable k) {
            convertVar.accept(k);
            return null;
        }

        @Override
        public Void apply(KSequence k) {
            sb.append("KSequence (");
            apply(k.items());
            sb.append(")");
            return null;
        }

        @Override
        public Void apply(InjectedKLabel k) {
            sb.append("InjectedKLabel (");
            apply(k.klabel());
            sb.append(")");
            return null;
        }

        private void apply(List<K> items) {
            for (K item : items) {
                apply(item);
                sb.append(" :: ");
            }
            sb.append("[]");
        }

        private void apply(Sort sort) {
            encodeStringToIdentifier(sb, sort.name());
        }

        public void apply(KLabel klabel) {
            if (klabel instanceof KVariable) {
                convertVar.accept((KVariable)klabel);
            } else {
                encodeStringToIdentifier(sb, klabel.name());
            }
        }
    }
}
