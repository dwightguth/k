package org.kframework.backend.ocaml.compile;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;
import org.kframework.attributes.Source;
import org.kframework.builtin.BooleanUtils;
import org.kframework.builtin.Sorts;
import org.kframework.definition.Module;
import org.kframework.definition.Production;
import org.kframework.definition.Rule;
import org.kframework.kil.Attribute;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kore.InjectedKLabel;
import org.kframework.kore.K;
import org.kframework.kore.KApply;
import org.kframework.kore.KLabel;
import org.kframework.kore.KRewrite;
import org.kframework.kore.KSequence;
import org.kframework.kore.KToken;
import org.kframework.kore.KVariable;
import org.kframework.kore.Sort;
import org.kframework.kore.ToKast;
import org.kframework.kore.compile.RewriteToTop;
import org.kframework.kore.compile.VisitKORE;
import org.kframework.krun.KRun;
import org.kframework.main.GlobalOptions;
import org.kframework.utils.BinaryLoader;
import org.kframework.utils.StringUtil;
import org.kframework.utils.errorsystem.KEMException;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;

import java.io.File;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Consumer;

import static org.kframework.Collections.*;
import static org.kframework.kore.KORE.*;

public class DefinitionToOcaml {

    public static void main(String[] args) {
        KExceptionManager kem = new KExceptionManager(new GlobalOptions());
        CompiledDefinition def = new BinaryLoader(kem).loadOrDie(CompiledDefinition.class, new File(args[0]));

        BiFunction<String, Source, K> programParser = def.getProgramParser(kem);

        K program = programParser.apply(
                "int s, n, .Ids; n = 10; while(0<=n) { s = s + n; n = n + -1; }", Source.apply("generated by DefinitionToOcaml"));

        DefinitionToOcaml convert = new DefinitionToOcaml();
        String ocaml = convert.convert(def);
        FileUtil.testFileUtil().saveToWorkingDirectory("def.ml", ocaml);
        String pgm = convert.convert(new KRun(kem, FileUtil.testFileUtil()).plugConfigVars(def, Collections.singletonMap(KToken(Sorts.KConfigVar(), "$PGM"), program)));
        FileUtil.testFileUtil().saveToWorkingDirectory("pgm.ml", pgm);
    }

    public static final String prelude = "type k = KApply of klabel * k list\n" +
            "           | KToken of sort * string\n" +
            "           | InjectedKLabel of klabel\n" +
            "           | KSequence of k list\n" +
            "           | Map of k KMap.t\n" +
            "\n" +
            "exception Stuck of k\n" +
            "type t = k\n" +
            "module KMap = Map.Make(Def)\n";

    public static final String midlude = "let isTrue(c: k) : bool = match c with\n" +
            "| KToken (Lbl0042006f006f006c, \"true\") -> true\n" +
            "| _ -> false\n" +
            "let rec print_k(c: k) : unit = match c with\n" +
            "| KApply(klabel, klist) -> print_klabel(klabel); print_string \"(\"; print_klist(klist); print_string \")\"\n" +
            "| KToken(sort, s) -> print_string \"#token(\"; print_sort(sort); print_string (\", \\\"\" ^ s ^ \"\\\")\")\n" +
            "| InjectedKLabel(klabel) -> print_string \"#klabel(\"; print_klabel(klabel); print_string(\")\")\n" +
            "| KSequence(k) -> print_ksequence(k)\n" +
            "and print_klist(c: k list) : unit = match c with\n" +
            "| [] -> print_string(\".KList\")\n" +
            "| e::l -> print_k(e); print_string(\", \"); print_klist(l)\n" +
            "and print_ksequence(c: k list) : unit = match c with\n" +
            "| [] -> print_string(\".K\")\n" +
            "| e::l -> print_k(e); print_string(\" ~> \"); print_ksequence(l)\n";

    public static final String postlude = "let run c =\n" +
            "  try let rec go c = go (step c)\n" +
            "      in go c\n" +
            "  with Stuck c' -> c'\n";
    public String convert(CompiledDefinition def) {
        Module mainModule = def.executionModule();
        return convert(mainModule);
    }

    Set<KLabel> functions;

    public String convert(K k) {
        StringBuilder sb = new StringBuilder();
        sb.append("open Def\n");
        sb.append("let _ = print_k(run(");
        convert(sb, v -> {
            throw KEMException.criticalError("Ocaml backend does not support symbolic terms.", v);
        }, functions).apply(k);
        sb.append("));");
        return sb.toString();
    }

    private String convert(Module mainModule) {
        StringBuilder sb = new StringBuilder();
        sb.append("type sort = ");
        for (Sort s : iterable(mainModule.definedSorts())) {
            sb.append("|");
            encodeStringToIdentifier(sb, s.name());
            sb.append("\n");
        }
        sb.append("type klabel = ");
        for (KLabel label : iterable(mainModule.definedKLabels())) {
            sb.append("|");
            encodeStringToIdentifier(sb, label.name());
            sb.append("\n");
        }
        sb.append(prelude);
        sb.append("let print_sort(c: sort) : unit = match c with \n");
        for (Sort s : iterable(mainModule.definedSorts())) {
            sb.append("|");
            encodeStringToIdentifier(sb, s.name());
            sb.append(" -> print_string ");
            sb.append(StringUtil.enquoteCString(StringUtil.enquoteKString(s.name())));
            sb.append("\n");
        }
        sb.append("let print_klabel(c: klabel) : unit = match c with \n");
        for (KLabel label : iterable(mainModule.definedKLabels())) {
            sb.append("|");
            encodeStringToIdentifier(sb, label.name());
            sb.append(" -> print_string ");
            sb.append(StringUtil.enquoteCString(ToKast.apply(label)));
            sb.append("\n");
        }
        sb.append(midlude);
        HashMultimap<KLabel, Rule> functionRules = HashMultimap.create();
        for (Rule r : iterable(mainModule.rules())) {
            K left = RewriteToTop.toLeft(r.body());
            boolean isFunction = left instanceof KApply && mainModule.attributesFor().apply(((KApply)left).klabel()).contains(Attribute.FUNCTION_KEY);
            if (isFunction) {
                functionRules.put(((KApply)left).klabel(), r);
            }
        }
        functions = new HashSet<>(functionRules.keySet());
        for (Production p : iterable(mainModule.productions())) {
            if (p.att().contains("function")) {
                functions.add(p.klabel().get());
            }
        }
        String conn = "let rec ";
        for (KLabel functionLabel : functionRules.keySet()) {
            sb.append(conn);
            encodeStringToFunction(sb, functionLabel.name());
            sb.append(" (l: k list) : k = match l with \n");
            for (Rule r : functionRules.get(functionLabel)) {
                convert(r, sb, functions, true);
            }
            sb.append("| _ -> raise (Stuck (KApply (");
            encodeStringToIdentifier(sb, functionLabel.name());
            sb.append(", l)))\n");
            conn = "and ";
        }
        sb.append("let step (c: k) : k = match c with \n");
        for (Rule r : iterable(mainModule.rules())) {
            if (!functionRules.values().contains(r)) {
                convert(r, sb, functions, false);
            }
        }
        sb.append("| _ -> raise (Stuck c)\n");
        sb.append(postlude);
        return sb.toString();
    }

    private static void encodeStringToIdentifier(StringBuilder sb, String name) {
        sb.append("Lbl");
        encodeStringToAlphanumeric(sb, name);
    }

    private static void encodeStringToFunction(StringBuilder sb, String name) {
        sb.append("eval");
        encodeStringToAlphanumeric(sb, name);
    }

    private static long counter = 0;

    private static String encodeStringToVariable(StringBuilder sb, String name) {
        StringBuilder sb2 = new StringBuilder();
        sb2.append("var");
        encodeStringToAlphanumeric(sb2, name);
        sb2.append("_");
        sb2.append(counter++);
        sb.append(sb2);
        return sb2.toString();
    }

    private static void encodeStringToAlphanumeric(StringBuilder sb, String name) {
        for (char c : name.toCharArray()) {
            sb.append(String.format("%04x", (int)c));
        }
    }


    private static void convert(Rule r, StringBuilder sb, Set<KLabel> functions, boolean function) {
        sb.append("(* rule ");
        sb.append(ToKast.apply(r.body()));
        sb.append(" requires ");
        sb.append(ToKast.apply(r.requires()));
        sb.append(" ensures ");
        sb.append(ToKast.apply(r.ensures()));
        sb.append(" ");
        sb.append(r.att().toString());
        sb.append("*)\n");
        sb.append("| ");
        K left = RewriteToTop.toLeft(r.body());
        K right = RewriteToTop.toRight(r.body());
        K requires = r.requires();
        SetMultimap<KVariable, String> vars = HashMultimap.create();
        Visitor visitor = convert(sb, v -> applyVarLhs(v, sb, vars), functions);
        if (function) {
            assert left instanceof KApply;
            KApply kapp = (KApply) left;
            visitor.apply(kapp.klist().items());
        } else {
            visitor.apply(left);
        }
        String result = convert(vars);
        if (!(result.equals("true") && requires.equals(BooleanUtils.TRUE))) {
            sb.append(" when isTrue(");
            convert(sb, v -> applyVarRhs(v, sb, vars), functions).apply(requires);
            sb.append(") && (");
            sb.append(result);
            sb.append(")");
        }
        sb.append(" -> ");
        convert(sb, v -> applyVarRhs(v, sb, vars), functions).apply(right);
        sb.append("\n");
    }

    private static String convert(SetMultimap<KVariable, String> vars) {
        StringBuilder sb = new StringBuilder();
        for (Collection<String> nonLinearVars : vars.asMap().values()) {
            if (nonLinearVars.size() < 2) {
                continue;
            }
            Iterator<String> iter = nonLinearVars.iterator();
            String last = iter.next();
            while (iter.hasNext()) {
                String next = iter.next();
                sb.append(last);
                sb.append(" = ");
                sb.append(next);
                last = next;
                sb.append(" && ");
            }
        }
        sb.append("true");
        return sb.toString();
    }

    private static void applyVarRhs(KVariable v, StringBuilder sb, SetMultimap<KVariable, String> vars) {
        sb.append(vars.get(v).iterator().next());
    }

    private static void applyVarLhs(KVariable k, StringBuilder sb, SetMultimap<KVariable, String> vars) {
        String varName = encodeStringToVariable(sb, k.name());
        vars.put(k, varName);
    }

    private static Visitor convert(StringBuilder sb, Consumer<KVariable> convertVar, Set<KLabel> functions) {
        return new Visitor(functions, sb, convertVar);
    }

    private static class Visitor extends VisitKORE {
        private final Set<KLabel> functions;
        private final StringBuilder sb;
        private final Consumer<KVariable> convertVar;

        public Visitor(Set<KLabel> functions, StringBuilder sb, Consumer<KVariable> convertVar) {
            this.functions = functions;
            this.sb = sb;
            this.convertVar = convertVar;
        }

        @Override
        public Void apply(KApply k) {
            if (functions.contains(k.klabel())) {
                encodeStringToFunction(sb, k.klabel().name());
                sb.append("(");
                apply(k.klist().items());
                sb.append(")");
            } else {
                sb.append("KApply (");
                apply(k.klabel());
                sb.append(", ");
                apply(k.klist().items());
                sb.append(")");
            }
            return null;
        }

        @Override
        public Void apply(KRewrite k) {
            throw new AssertionError("unexpected rewrite");
        }

        @Override
        public Void apply(KToken k) {
            sb.append("KToken (");
            apply(k.sort());
            sb.append(", ");
            sb.append(StringUtil.enquoteCString(k.s()));
            sb.append(")");
            return null;
        }

        @Override
        public Void apply(KVariable k) {
            convertVar.accept(k);
            return null;
        }

        @Override
        public Void apply(KSequence k) {
            sb.append("KSequence (");
            apply(k.items());
            sb.append(")");
            return null;
        }

        @Override
        public Void apply(InjectedKLabel k) {
            sb.append("InjectedKLabel (");
            apply(k.klabel());
            sb.append(")");
            return null;
        }

        private void apply(List<K> items) {
            for (K item : items) {
                apply(item);
                sb.append(" :: ");
            }
            sb.append("[]");
        }

        private void apply(Sort sort) {
            encodeStringToIdentifier(sb, sort.name());
        }

        public void apply(KLabel klabel) {
            if (klabel instanceof KVariable) {
                convertVar.accept((KVariable)klabel);
            } else {
                encodeStringToIdentifier(sb, klabel.name());
            }
        }
    }
}
