--- syntax used by the tcp interface and the tcp backend
mod TCP-SYNTAX is
	including SOCKET .
        including STRING .
	
	op #error : -> [String] .
	op #containedRequest : Configuration -> [String] .
	op #toSend : String -> Msg .
	op #start : Nat -> Configuration .
	op #tcpRequest : String -> String .
	op #TCPPORT : -> [Nat] .
	eq #TCPPORT = 7500 [owise] . --- default in case there is no other port set
endm

mod TCP-CLIENT is
	including TCP-SYNTAX .
    including CONVERSION .
	
	sort #TCPState .
		
	op Client : -> Cid .
	op cnum : Nat -> Oid .
	op #checkAnswer : Oid String ~> String .
	eq #checkAnswer(cnum(N),S) = #checkAnswer-aux(string(N, 10), find(S, "\001", 0), S) .
	op #checkAnswer-aux : String Nat String ~> String .
	ceq #checkAnswer-aux(SN:String, P:Nat, S)
			= substr(S, P:Nat + 1, length(S))
		if SN:String = substr(S,0,P:Nat) 
		[print SN:String ", " S ", " P:Nat] .
	
	ops #idle #connecting sending receiving #haveAnswer #closing #connected #finished : -> #TCPState [ctor] .
	
	op #state:_ : #TCPState -> Attribute [ctor] .
	op answer:_ : String -> Attribute [ctor] .
	op #connectedTo:_ : Oid -> Attribute [ctor] .
	
		
	vars Me Server : Oid .
	var A : AttributeSet .
	var S S2 : String .
	var M : Msg .
	var C : Configuration .
	var N : Nat .
	
	rl < Me : Client | #state: #connecting, A > createdSocket(Me, socketManager, Server)
	=> < Me : Client | #state: #connected, #connectedTo: Server, A >
	[print Me " connected"] .
	
	----- errors
	eq #containedRequest(C socketError(Me, socketManager, S))
	= #error
	[print Me " socket error: " S] .
	eq #containedRequest(C < Me : Client | #state: #connecting,  A > closedSocket(Me, Server, S))
	= #error
	[print Me " error connecting: " S] .
	eq #containedRequest(C < Me : Client | #state: receiving,  A > closedSocket(Me, Server, S))
	= #error
	[print Me " error receiving: " S] .
	-----
	
	rl < Me : Client | #state: #connected,  #connectedTo: Server,  A > #toSend(S)
	=> < Me : Client | #state: sending,  #connectedTo: Server,  A > send(Server, Me, S)
	[print Me " sending"] .
	
	rl < Me : Client | #state: sending,  A > sent(Me, Server)
	=> < Me : Client | #state: receiving, answer: "",  A > receive(Server, Me)
	[print Me " receiving"] .
	
	rl < Me : Client | #state: receiving,  answer: S, A >  received(Me, Server, S2)
	=> < Me : Client | #state: receiving,  answer: (S + S2),  A > receive(Server, Me)
	[print Me " have answer"] .

	rl < Me : Client | #state: receiving, A > closedSocket(Me, Server, S)
	=> < Me : Client | #state: #finished,  A  >
	[print Me " finished"] .
	
	rl #containedRequest(<> < Me : Client | #state: #finished,  answer: S,  A  >)
	=> #checkAnswer(Me, S)
	[print Me " popping out of socket stuff"] .
	
	rl #start(N) => 
		<>
		< cnum(N) : Client | #state: #connecting >
		createClientTcpSocket(socketManager, cnum(N), "localhost", #TCPPORT) .

endm

mod TCP is
	including TCP-SYNTAX .
	including TCP-CLIENT .
	including K-COUNTER .
	including CONVERSION .
	
        op #errorTCPSyntax : String -> String .

	eq #tcpRequest(S:String) = #tcpRequest(S:String, counter) .

	op #tcpRequest : String [Nat] -> [String] .
	eq #tcpRequest(S:String, N:Nat) = 
#checkResult(#containedRequest(#start(N:Nat) #toSend(string(N:Nat, 10) + "\001" + string(length(S:String), 10) + "\001" + S:String))) .

	op #checkResult : String -> String .
	op #getTCPData : String -> String .


	ceq #checkResult(S:String) = #getTCPData(substr(S:String, length("success\001"), length(S:String)))
		if substr(S:String, 0, length("success#")) == "success\001" [print "full output: " S:String] .

	ceq #getTCPData(S:String)
			= substr(S:String, 0, N:Nat)
		if N:Nat := find(S:String, "\001\001\001", 0) .

	eq #getTCPData(S:String)
		= #errorTCPSyntax("Incorrect Output: " + S:String) [owise] .
		
	ceq #checkResult(S:String) = #errorTCPSyntax(#getTCPData(substr(S:String, length("fail\001"), length(S:String))))
		if substr(S:String, 0, length("fail\001")) == "fail\001" [print "full error string: " S:String] .
		
	eq #checkResult("") = #errorTCPSyntax("Unknown error") .
	eq #checkResult(#error) = #errorTCPSyntax("Unknown error") .

	op #isTCPError : String -> Bool .
	eq #isTCPError(#errorTCPSyntax(S:String)) = true .
	ceq #isTCPError(S:String) = false
		if length(S:String) >= 0 . --- dummy check to make sure it's a real string
	--- eq #isTCPError(S:String) = false [owise] . --- unsafe

        op #retrieveTCPError : String -> String .
        eq #retrieveTCPError(#errorTCPSyntax(S:String)) = S:String .
endm
