// Copyright (c) 2014-2015 K Team. All Rights Reserved.

package org.kframework.kore.convertors;

import com.google.inject.Guice;
import com.google.inject.Injector;
import com.google.inject.name.Names;
import org.junit.Test;
import org.junit.rules.TestName;
import org.kframework.attributes.Source;
import org.kframework.backend.java.compile.KOREtoBackendKIL;
import org.kframework.backend.java.indexing.IndexingTable;
import org.kframework.backend.java.kil.ConstrainedTerm;
import org.kframework.backend.java.kil.Definition;
import org.kframework.backend.java.kil.GlobalContext;
import org.kframework.backend.java.kil.KLabelConstant;
import org.kframework.backend.java.kil.TermContext;
import org.kframework.backend.java.symbolic.JavaExecutionOptions;
import org.kframework.backend.java.symbolic.JavaSymbolicCommonModule;
import org.kframework.backend.java.symbolic.KILtoBackendJavaKILTransformer;
import org.kframework.backend.java.symbolic.SymbolicRewriter;
import org.kframework.backend.java.util.JavaKRunState;
import org.kframework.definition.Module;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kompile.Kompile;
import org.kframework.kompile.KompileOptions;
import org.kframework.kore.K;
import org.kframework.krun.api.KRunState;
import org.kframework.krun.api.io.FileSystem;
import org.kframework.krun.ioserver.filesystem.portable.PortableFileSystem;
import org.kframework.main.GlobalOptions;
import org.kframework.main.Tool;
import org.kframework.parser.ProductionReference;
import org.kframework.unparser.AddBrackets;
import org.kframework.unparser.KOREToTreeNodes;
import org.kframework.utils.errorsystem.KEMException;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import org.kframework.utils.inject.RequestScoped;
import org.kframework.utils.inject.SimpleScope;
import org.kframework.utils.options.SMTOptions;
import scala.collection.JavaConversions;

import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.util.function.BiFunction;

import static org.kframework.Collections.*;
import static org.kframework.definition.Constructors.*;

public class TstBackendOnKORE_IT {

    @org.junit.Rule
    public TestName name = new TestName();

    protected File testResource(String baseName) throws URISyntaxException {
        return new File(TstTinyOnKORE_IT.class.getResource(baseName).toURI());
    }

    @Test
    public void kore_imp() throws IOException, URISyntaxException {

        String filename = "/convertor-tests/" + name.getMethodName() + ".k";

        File definitionFile = testResource(filename);
        KExceptionManager kem = new KExceptionManager(new GlobalOptions());
        GetSymbolicRewriter getSymbolicRewriter = null;
        try {
            CompiledDefinition compiledDef = new Kompile(FileUtil.testFileUtil(), kem, false).run(definitionFile, "IMP", "IMP-SYNTAX", "K");

            BiFunction<String, Source, K> programParser = compiledDef.getProgramParser();

            K program = programParser.apply(
                    "<T><k> while(0<=n) { s = s + n; n = n + -1; } </k><state>n|->10 s|->0</state></T>", Source.apply("generated by " + getClass().getSimpleName()));

            getSymbolicRewriter = new GetSymbolicRewriter(compiledDef.executionModule(), kem).invoke();
            KOREtoBackendKIL converter = new KOREtoBackendKIL(getSymbolicRewriter.termContext);
            JavaKRunState result = (JavaKRunState) getSymbolicRewriter.getRewriter().rewrite(new ConstrainedTerm(converter.convert(program), getSymbolicRewriter.termContext), getSymbolicRewriter.termContext.definition().context(), -1, false);
            K kResult = result.getJavaKilTerm();
            Module unparsingModule = compiledDef.getParserModule(Module("UNPARSING", Set(compiledDef.executionModule(), compiledDef.syntaxModule(), compiledDef.getParsedDefinition().getModule("K-SORT-LATTICE").get()), Set(), Att()));
            System.err.println(KOREToTreeNodes.toString(new AddBrackets(unparsingModule).addBrackets((ProductionReference) KOREToTreeNodes.apply(KOREToTreeNodes.up(kResult), unparsingModule))));
        } finally {
            if (getSymbolicRewriter != null) {
                getSymbolicRewriter.getRequestScope().exit();
            }
            kem.print();
        }
    }

    @Test
    public void kore_csemantics() throws IOException, URISyntaxException {
        String filename = "/home/dwightguth/c-semantics/semantics/c11-translation.k";
        KExceptionManager kem = new KExceptionManager(new GlobalOptions());
        try {
            CompiledDefinition rwModuleAndProgramParser = new Kompile(FileUtil.testFileUtil(), kem).run(new File(filename),
                    "C11-TRANSLATION", "C11-TRANSLATION", "K");
            K program = rwModuleAndProgramParser.getProgramParser().apply("t(.Set, int) ==Type t(.Set, int)", Source.apply("generated by " + getClass().getSimpleName()));
            GetSymbolicRewriter getSymbolicRewriter = new GetSymbolicRewriter(rwModuleAndProgramParser.executionModule(), kem).invoke();
            KOREtoBackendKIL converter = new KOREtoBackendKIL(getSymbolicRewriter.termContext);
            getSymbolicRewriter.getRewriter().rewrite(new ConstrainedTerm(converter.convert(program), getSymbolicRewriter.termContext), getSymbolicRewriter.termContext.definition().context(), -1, false);
        } catch (KEMException e) {
            kem.addKException(e.exception);
            throw e;
        } finally {
            kem.print();
        }
    }

    private class GetSymbolicRewriter {
        private final Module module;
        private final KExceptionManager kem;
        private Definition definition;
        private TermContext termContext;
        private SymbolicRewriter rewriter;
        private SimpleScope requestScope;

        public GetSymbolicRewriter(Module module, KExceptionManager kem) {
            this.module = module;
            this.kem = kem;
        }

        public Definition getDefinition() {
            return definition;
        }

        public TermContext getTermContext() {
            return termContext;
        }

        public SymbolicRewriter getRewriter() {
            return rewriter;
        }

        public SimpleScope getRequestScope() { return requestScope; }

        public GetSymbolicRewriter invoke() {
            definition = new Definition(module, kem);

            requestScope = new SimpleScope();
            Injector injector = Guice.createInjector(new JavaSymbolicCommonModule() {
                @Override
                protected void configure() {
                    super.configure();
                    bind(GlobalOptions.class).toInstance(new GlobalOptions());
                    bind(SMTOptions.class).toInstance(new SMTOptions());
                    bind(Definition.class).toInstance(definition);
                    bind(Tool.class).toInstance(Tool.KRUN);
                    bind(FileSystem.class).to(PortableFileSystem.class);
                    bind(ProcessBuilder.class).toProvider(ProcessBuilder::new);
                    bind(FileUtil.class).toInstance(FileUtil.testFileUtil());

                    bindScope(RequestScoped.class, requestScope);
                    bind(SimpleScope.class).annotatedWith(Names.named("requestScope")).toInstance(requestScope);
                }
            });
            requestScope.enter();
            termContext = TermContext.of(injector.getInstance(GlobalContext.class));
            termContext.global().setDefinition(definition);

            JavaConversions.setAsJavaSet(module.attributesFor().keySet()).stream()
                    .map(l -> KLabelConstant.of(l.name(), definition))
                    .forEach(definition::addKLabel);
            definition.addKoreRules(module, termContext);

            definition = KILtoBackendJavaKILTransformer.expandAndEvaluateDefinition(termContext.global(), kem);

            definition.setIndex(new IndexingTable(() -> definition, new IndexingTable.Data()));

            rewriter = new SymbolicRewriter(definition, new KompileOptions(), new JavaExecutionOptions(), new KRunState.Counter());
            return this;
        }
    }
}
